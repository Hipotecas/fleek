{
    "version": "https://jsonfeed.org/version/1",
    "title": "Fleek Network Docs Blog",
    "home_page_url": "https://docs.fleek.network/fleek/blog",
    "description": "Fleek Network Docs Blog",
    "items": [
        {
            "id": "bloom-and-cuckoo-filters-for-cache-summarization",
            "content_html": "<p><img loading=\"lazy\" src=\"/fleek/assets/images/bloom-79da0db687b4fb2060758838b9c44513.png\" width=\"1200\" height=\"628\" class=\"img_ev3q\"></p><p>Disclaimer: This is not a general comparison between Bloom filters and Cuckoo filters. This blog post summarizes some of the experiments we conducted to decide whether or not we should replace our implementation of Counting Bloom filters with Cuckoo filters, for a specific use case.</p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"background\">Background<a class=\"hash-link\" href=\"#background\" title=\"Direct link to heading\">​</a></h2><p>Nodes on Fleek Network currently use Counting Bloom filters to summarize their cached content. These cache summaries are exchanged with other nodes in order to facilitate content routing.</p><p>If a particular node does not store a requested piece of content, it can use the Bloom filters that it received from its peers to check if a peer stores the requested content.</p><p>We are using Counting Bloom filters rather than regular Bloom filters because we need to be able to remove elements from the filter to support cache eviction.</p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"bloom-filters\">Bloom Filters<a class=\"hash-link\" href=\"#bloom-filters\" title=\"Direct link to heading\">​</a></h2><p>A Bloom filter is a space-efficient probabilistic data structure that can be used to perform approximate set membership queries.\nThe answer to an approximate set membership query is not <code>no</code> or <code>yes,</code> but rather <code>no</code> or <code>probably.</code> This <code>probably</code> is quantified with the false positive rate.  </p><p>One of the convenient features of Bloom filters is that they can be configured to have a specific false positive rate.\nOf course, there is a tradeoff here; the lower the false positive rate, the larger the memory footprint. Bloom filters support two operations: <code>insert</code> and <code>contains.</code>  </p><p>A Bloom filter is represented by an array of m bits together with k independent hash functions. To insert an element into the filter, it is hashed with each of the k hash functions.\nThe resulting hashes are interpreted as integers (modulo m) to obtain k array positions. The bits at these positions are then set to 1 (if there aren't already 1).<br>\n<!-- -->To check whether or not an element is contained in the filter, the element is hashed k times with the different hash functions.</p><p>If all bits at the resulting array positions are 1, the element is assumed to be present. If any of the k bits are zero, we can be certain that the queried element is not present in the set.</p><p>However, even if all bits are 1, it might still be the case that the bits were set by a combination of other elements. This is where the aforementioned false positive rate comes into play.  </p><p>Since we also need a <code>remove</code> operation for our use case, we have been using Counting Bloom filters, a variant of Bloom filters.\nCounting Bloom filters retain most of the properties that regular Bloom filters have. The <code>remove</code> operation comes at the cost of an increased memory footprint.</p><p>Each position in the array is no longer a single bit but a group of bits representing a counter.\nWhenever an element is inserted into the filter, the counters for all k positions are incremented by 1. To remove an element, we decrement the counters.</p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"cuckoo-filters\">Cuckoo Filters<a class=\"hash-link\" href=\"#cuckoo-filters\" title=\"Direct link to heading\">​</a></h2><p>Bloom filters are the most known members of a class of data structures called Approximate Membership Query Filters (AMQ Filters).\nA relatively recent addition to this class is the Cuckoo filter <!-- -->[1]<!-- -->. Cuckoo filters share many similarities with Bloom filters, especially Counting Bloom filters.</p><p>They are space-efficient and can be used for approximate set membership queries. Cuckoo filters also support the operations <code>insert,</code> <code>contains,</code> and <code>remove,</code> and have configurable false positive rates.  </p><p>Cuckoo filters are based on Cuckoo hash tables <!-- -->[2]<!-- --> and leverage an optimization called partial-key cuckoo hashing. A basic Cuckoo hash table consists of an array of buckets.\nWe determine two candidate buckets for each element using two different hash functions, h1 and h2.  </p><p>The <code>contains</code> operation will check if either bucket contains the element.\nFor insertion, if either bucket is empty, the element will be inserted into the empty bucket.</p><p>If neither bucket is empty, one of the buckets is selected, and the existing element is removed and inserted into its alternate location.\nThis may trigger another relocation if the alternate location is not empty.  </p><p>Although the insertion operation may perform a sequence of relocations, the amortized runtime is O(1).  </p><p>Most implementations of Cuckoo hash tables and, consequently, Cuckoo filters will use buckets that can hold multiple elements, as proposed in <!-- -->[3]<!-- -->.</p><p>For Cuckoo filters, the hash table size is reduced by only storing fingerprints - a bit string calculated from an element's hash - rather than key-value pairs.</p><p>The fingerprint size is derived from the desired false positive rate.<br>\n<!-- -->A problem that arises is that, to relocate existing fingerprints using the Cuckoo hashing approach described above, we need the original hash from which the fingerprint was derived.</p><p>Of course, we could store this hash somewhere, but the whole point of using fingerprints is to reduce the memory footprint of the filter.</p><p>The solution to this predicament is the aforementioned partial-key cuckoo hashing, a technique for determining an element's alternate location using only its fingerprint.<br>\n<!-- -->For a given element x, the two candidate buckets are computed as follows:  </p><p><img loading=\"lazy\" src=\"/fleek/assets/images/math-formul-a247d4df475b26b1e7cbb2acfc0ab8c2.png\" width=\"1324\" height=\"194\" class=\"img_ev3q\"></p><p>An important property of this technique is that h1(x) can also be computed from h2(x) and the fingerprint.</p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"benchmarking\">Benchmarking<a class=\"hash-link\" href=\"#benchmarking\" title=\"Direct link to heading\">​</a></h2><p>As this post mentioned, we are not aiming for a general comparison of Counting Bloom and Cuckoo filters.</p><p>Instead, we want to determine which filter suits our specific use case better. The two main properties we are looking for are space efficiency and lookup performance.  </p><p>Space efficiency is important because nodes frequently update their cache and have to communicate these changes with their peers. These messages should take up as little bandwidth as possible.</p><p>Lookup speed is also important because Fleek Network aims to serve user requests as quickly as possible. Checking whether a peer has some content stored in their cache summary should not be a bottleneck.  </p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"experimental-setup\">Experimental Setup<a class=\"hash-link\" href=\"#experimental-setup\" title=\"Direct link to heading\">​</a></h2><p>We are using our own Counting Bloom filter <a href=\"https://github.com/fleek-network/ursa/blob/483f4d56cbaa5e83182454d2c1db6f6af7c54912/crates/ursa-network/src/utils/bloom_filter.rs#L11\" target=\"_blank\" rel=\"noopener noreferrer\">implementation</a> and\n<a href=\"https://github.com/sile/scalable_cuckoo_filter\" target=\"_blank\" rel=\"noopener noreferrer\">this</a> Cuckoo filter implementation in Rust (the <a href=\"https://github.com/efficient/cuckoofilter\" target=\"_blank\" rel=\"noopener noreferrer\">original</a> implementation is in C++). All experiments\nwere performed on a Linux machine with 16 GB RAM and an Intel Core i7 (10th Gen). Whenever the experiment is probabilistic, we repeat the experiment 20 times and report the mean and standard deviation.</p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"memory-footprint\">Memory Footprint<a class=\"hash-link\" href=\"#memory-footprint\" title=\"Direct link to heading\">​</a></h2><p>For both Counting Bloom filters and Cuckoo filters, the memory footprint is determined by two factors: the filter's capacity and the desired false positive rate. In the first experiment, we examine the impact that\nthese factors have on the memory footprint.  </p><p>To this end, we fix the false positive rate and initialize the filters with capacities ranging from 100K to 1M. The result is shown in Fig. 1.\nThe size of Bloom filters scales linearly with the capacity. Cuckoo filters are more space-efficient. This result is consistent with the experiments reported in <!-- -->[1]<!-- -->.</p><p><img loading=\"lazy\" src=\"/fleek/assets/images/capacity-size-5c2576bd69db0e5b510781e7cc1c5257.png\" width=\"640\" height=\"480\" class=\"img_ev3q\"></p><blockquote><p>Figure 1: We fix the false positive rate and initialize the filters with capacities ranging from 100K to 1M. The y-axis shows the size of the filters in Megabytes.</p></blockquote><p>Next, we fix the capacity and initialize the filters with false positive rates ranging from 0.0001 to 0.5. Fig. 2 shows that Cuckoo filters are more space-efficient.</p><p>The gap between Counting Bloom filters and Cuckoo filters grows as the false positive rate decreases. This is also consistent with experiments in <!-- -->[1]<!-- -->.</p><p><img loading=\"lazy\" src=\"/fleek/assets/images/fp-rate-size-fbb54b2450b4a91e28c97d8adf0253e8.png\" width=\"640\" height=\"480\" class=\"img_ev3q\"></p><blockquote><p>Figure 2: We fix the capacity and initialize the filters with false positive rates ranging from 0.0001 to 0.5. The y-axis shows the size of the filters in Megabytes.</p></blockquote><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"lookup-performance\">Lookup Performance<a class=\"hash-link\" href=\"#lookup-performance\" title=\"Direct link to heading\">​</a></h2><p>We first add elements to both filters until the capacity is reached. We then measure the lookup performance for different ratios of positive and negative lookups.</p><p>A positive lookup is for an existing element, and a negative lookup is for an element not contained in the filter. We perform 100K lookups for each ratio and report the average lookup duration and standard deviation. </p><p>Fig. 3 shows the results. Bloom filters perform slightly better on average than Cuckoo filters. This result is inconsistent with <!-- -->[1]<!-- -->,\nwhere Cuckoo filters were reported to have a better lookup performance than Bloom filters. It should be noted here that the authors in <!-- -->[1]<!-- --> use the original C++ Cuckoo filter implementation and their own unreleased Bloom filter implementation. In contrast, we use a Rust Cuckoo filter implementation and our Bloom filter implementation. We cannot easily determine the reason for this discrepancy.</p><p>However, the performance difference is negligible.</p><p><img loading=\"lazy\" src=\"/fleek/assets/images/lookup-e36011237d8602b5f6c36fe5dd145bf5.png\" width=\"640\" height=\"480\" class=\"img_ev3q\"></p><blockquote><p>Figure 3: Lookup performance for different ratios of positive and negative lookups. For example, ratio 0.25 indicates that 25% of lookups are positive and 75% are negative.\nThe shaded region indicates the standard deviation.</p></blockquote><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"insertion-performance\">Insertion Performance<a class=\"hash-link\" href=\"#insertion-performance\" title=\"Direct link to heading\">​</a></h2><p>Less critical than lookup performance but still important for our purposes is insertion performance. We measure how the insertion performance varies for different occupancy levels.\nFig. 4 shows the results. The insertion performance is constant across all levels of occupancy for Bloom filters.</p><p>For Cuckoo filters, the performance decreases as the filter becomes fuller because more relocations are required. In Fig. 4, the performance for Bloom filters is not constant. It quickly increases and then remains constant. This can be explained by CPU caching. </p><p><img loading=\"lazy\" src=\"/fleek/assets/images/insert-3ff48d4c63724adcf399f81b29607691.png\" width=\"640\" height=\"480\" class=\"img_ev3q\"></p><blockquote><p>Figure 4: Insertion performance for different occupancy levels. The shaded region indicates the standard deviation.</p></blockquote><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"capacity-and-scaling\">Capacity and Scaling<a class=\"hash-link\" href=\"#capacity-and-scaling\" title=\"Direct link to heading\">​</a></h2><p>We have mentioned the capacity of a filter several times now. An interesting case is what happens when a filter's capacity is exceeded.\nBloom filters and Cuckoo filters behave differently in this scenario.</p><p>For Bloom filters, the <code>insertion</code> operation always succeeds. However, the false positive rate will rapidly increase as we exceed the filter's capacity. While Bloom filters fail silently, Cuckoo filters are more explicit. Most implementations have a maximum number of\nrelocations that will be performed for an insertion. The <code>insertion</code> operation will return an error if more relocations are required.  </p><p>For both filters, we can avoid this problem by simply initializing the filter with a sufficiently large capacity. However, this will increase the memory footprint of the filter.</p><p>Furthermore, it is difficult to predict how many elements a node on Fleek Network will cache. It is also likely that the number of cached elements will greatly vary for different nodes.  </p><p>Fortunately, a variant of Bloom filters called Scalable Bloom Filters <!-- -->[4]<!-- --> can adapt dynamically to the number of elements stored while guaranteeing a maximum false positive rate.</p><p>The proposed technique is also applicable to Cuckoo filters.</p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"other-filters\">Other Filters<a class=\"hash-link\" href=\"#other-filters\" title=\"Direct link to heading\">​</a></h2><p>While we only looked at Bloom filters and Cuckoo filters, there are other AMQ filters that we want to mention here briefly:</p><ul><li><p>Quotient filters <!-- -->[5, 6]<!-- -->: Compact hash tables that support insertion, lookup, and deletion. Less space-efficient than Bloom filters and Cuckoo filters.  </p></li><li><p>XOR filters <!-- -->[7]<!-- -->: More space-efficient than Bloom filters and Cuckoo filters. However, they are static, meaning the filter has to be rebuilt if additional elements are added. </p></li></ul><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"conclusion\">Conclusion<a class=\"hash-link\" href=\"#conclusion\" title=\"Direct link to heading\">​</a></h2><p>We examined whether Counting Bloom filters or Cuckoo filters are more suitable for summarizing caches on Fleek Network. Cuckoo filters are more space-efficient, especially for lower false positive rates. Bloom filters have a slightly better insertion and lookup performance for the implementations we tested.</p><p>Both filters can be adapted to grow and shrink in size dynamically. Since the difference in insertion and lookup performance is negligible while Cuckoo filters are significantly more space-efficient, we favor Cuckoo filters for our use case.  </p><h3 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"references\">References<a class=\"hash-link\" href=\"#references\" title=\"Direct link to heading\">​</a></h3><p>[1]<!-- --> Bin Fan, Dave G. Andersen, Michael Kaminsky, and Michael D. Mitzenmacher. Cuckoo Filter: Practically Better Than Bloom.\nIn Proceedings of the 10th ACM International Conference on emerging Networking Experiments and Technologies (CoNEXT 14). Association for Computing Machinery, New York, NY, USA, pp. 75-88, 2014.  </p><p>[2]<!-- --> Rasmus Pagha and Flemming Friche Rodler. Cuckoo hashing. Journal of Algorithms, 51(2), pp. 122-144, 2004.  </p><p>[3]<!-- --> Martin Dietzfelbinger and Christoph Weidling. Balanced Allocation and Dictionaries with Tightly Packed Constant Size Bins. Theoretical Computer Science, 380(1), pp. 47-68, 2007.  </p><p>[4]<!-- --> Paulo S. Almeida, Carlos Baquero, Nuno Preguiça, and David Hutchison. Scalable Bloom Filters. Information Processing Letters, 101(6), pp. 255-261, 2007.  </p><p>[5]<!-- --> John G. Cleary. Compact hash tables using bidirectional linear probing. IEEE Transactions on Computers. 33(9), pp. 828-834, 1984.  </p><p>[6]<!-- --> Anna Pagh, Rasmus Pagh, and S. Srinivasa Rao. An optimal Bloom filter replacement. Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 823-829, 2005. </p><p>[7]<!-- --> Thomas Mueller Graf and Daniel Lemire. Xor Filters: Faster and Smaller Than Bloom and Cuckoo Filters. ACM Journal of Experimental Algorithmics. 25, pp. 1-16, 2020.</p>",
            "url": "https://docs.fleek.network/fleek/blog/bloom-and-cuckoo-filters-for-cache-summarization",
            "title": "Bloom Filters and Cuckoo Filters for Cache Summarization",
            "summary": "Summary of our experiment informing whether or not we should replace our implementation of Counting Bloom filters with Cuckoo filters.",
            "date_modified": "2023-02-16T01:41:34.000Z",
            "author": {
                "name": "Matthias Wright",
                "url": "https://github.com/matthias-wright"
            },
            "tags": [
                "fleek network",
                "blog",
                "engineering",
                "content routing"
            ]
        },
        {
            "id": "the-fleek-network",
            "content_html": "<h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"introduction\">Introduction<a class=\"hash-link\" href=\"#introduction\" title=\"Direct link to heading\">​</a></h2><p>Fleek Network is a decentralized content and application layer built on established decentralized storage protocols combined with high-speed caching and an effective delivery layer. An alternative to traditional content delivery networks without a central authority that is reliable and censorship-resistant. Fleek Network relies on blockchain technology at its core, allowing governance\nand token rewards as incentives for participation in serving the network.</p><p>💡 This content was originally posted in <a href=\"https://hackmd.io/5jExeM1yQ7Sm_ly-6cp0ng\" target=\"_blank\" rel=\"noopener noreferrer\">hackmd.io</a></p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"motivation\">Motivation<a class=\"hash-link\" href=\"#motivation\" title=\"Direct link to heading\">​</a></h2><p>Storage based traffic makes up 80% of Fleek traffic, the other 20% is for our websites.</p><p><img loading=\"lazy\" src=\"/fleek/assets/images/pie-chart-storage-based-trafic-d4ee2a9162b344590b457a113f872bcc.jpg\" width=\"838\" height=\"474\" class=\"img_ev3q\"></p><blockquote><p>Globally, gaming traffic will be 6% of consumer Internet traffic in 2021, up from 2% in 2016...</p><p><a href=\"https://www.cisco.com/c/dam/m/en_us/solutions/service-provider/vni-forecast-highlights/pdf/Global_2021_Forecast_Highlights.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Cisco Research</a></p></blockquote><blockquote><p>Globally, consumer Internet video traffic will be 81% of consumer Internet traffic in 2021, up from 72% in 2016.</p><p><a href=\"https://www.cisco.com/c/dam/m/en_us/solutions/service-provider/vni-forecast-highlights/pdf/Global_2021_Forecast_Highlights.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Cisco Research</a></p></blockquote><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"whats-next-for-fleek\">Whats next for Fleek?<a class=\"hash-link\" href=\"#whats-next-for-fleek\" title=\"Direct link to heading\">​</a></h2><p>Decentralize our entire stack! Today we start with an important piece in our stack, the CDN.</p><ul><li>Accelerate IPFS content retrieval</li><li>Better UX for storage and hosting</li><li>Become non-custodial</li></ul><hr><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"fleek-network\">Fleek Network<a class=\"hash-link\" href=\"#fleek-network\" title=\"Direct link to heading\">​</a></h2><ul><li>Decentralized</li><li>Scale with demand</li><li>Web3 content</li><li>Interoperable</li><li>Robustness</li><li>P2P</li></ul><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"architecture\">Architecture<a class=\"hash-link\" href=\"#architecture\" title=\"Direct link to heading\">​</a></h2><ul><li>Content Routing</li><li>GossipSub</li><li>DHT</li><li>Peer discovery</li><li>DHT (Kademlia)</li><li>Request/Response</li><li>Bitswap/Graphsync</li><li>Gateway </li></ul><p><img loading=\"lazy\" src=\"/fleek/assets/images/fleek-network-architecture-7a789083f96da278ddb57aa3dea0a297.jpg\" width=\"6361\" height=\"2282\" class=\"img_ev3q\"></p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"p2p\">P2P<a class=\"hash-link\" href=\"#p2p\" title=\"Direct link to heading\">​</a></h2><p><img loading=\"lazy\" src=\"/fleek/assets/images/diagram-p2p-949ce65d7e06bf1bf8969bba2c2949e9.png\" width=\"1987\" height=\"1632\" class=\"img_ev3q\"></p><ul><li>Libp2p based</li><li>Trustless</li><li>Censorship-resistant</li><li>Resilient</li><li>Gossiping Protocol</li><li>Content addressable</li></ul><hr><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"content-routing\">Content Routing<a class=\"hash-link\" href=\"#content-routing\" title=\"Direct link to heading\">​</a></h2><ul><li>DHT based content routing</li><li>Gossip based routing<ul><li>Bitswap</li><li>Graphsync Req/Res</li></ul></li><li>Not permanent<ul><li>Cache eviction</li></ul></li></ul><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"peer-discovery\">Peer Discovery<a class=\"hash-link\" href=\"#peer-discovery\" title=\"Direct link to heading\">​</a></h2><ul><li>DHT (Kademlia)</li><li>mDns</li><li>Pruning and Grafting, passing lists of peers </li><li>Relay Nodes for nodes behind firewalls</li><li>Fleek Bootstrap nodes</li><li>Act as the network orchestrators</li><li>Gossip Only</li><li>Peer exchange through our Fleek bootstrap nodes</li></ul><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"consensus\">Consensus<a class=\"hash-link\" href=\"#consensus\" title=\"Direct link to heading\">​</a></h2><p><img loading=\"lazy\" src=\"/fleek/assets/images/fleek-network-consensus-c8f1ab3f9f5e6c7d0e013686b4e1b7e1.png\" width=\"3722\" height=\"1513\" class=\"img_ev3q\"></p><ul><li>Narwhal and Bullshark<ul><li>Data availability is ensured using Narwhal</li><li>Bullshark over Tusk for ordering</li></ul></li></ul><p><strong>Comparing Tusk vs Bullshark:</strong></p><table><thead><tr><th></th><th>Common round latency</th><th>Async round latency</th><th>Garbage collection</th><th>Fairness</th></tr></thead><tbody><tr><td>Tusk</td><td>3</td><td>E(7)</td><td>yes</td><td>no</td></tr><tr><td>Bullshark</td><td>2</td><td>E(6)</td><td>yes</td><td>during sync</td></tr></tbody></table><p>Click <a href=\"/fleek/docs/whitepaper\">here</a> to find more information about the Fleek Network consensus.</p><blockquote><p>Decoupling data dissemination from metadata ordering is the key mechanism to allow scalable and high throughput consensus systems </p><p><a href=\"https://arxiv.org/pdf/2105.11827.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Narwhal &amp; Tusk</a></p></blockquote><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"indexer\">Indexer<a class=\"hash-link\" href=\"#indexer\" title=\"Direct link to heading\">​</a></h2><p><img loading=\"lazy\" src=\"/fleek/assets/images/fleek-network-indexer-adcafab45fa648dd3dee8df250c8d55a.png\" width=\"2350\" height=\"1159\" class=\"img_ev3q\"></p><ul><li>Each cache node runs an index provider</li><li>Index provider announces the content availability to indexer</li><li>Indexer get the nodes (for Bitswap/GraphSync) that are holding the content</li><li>Accelerates content routing and discovery</li></ul><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"gateway\">Gateway<a class=\"hash-link\" href=\"#gateway\" title=\"Direct link to heading\">​</a></h2><ul><li>Cherry Picker</li><li>Minimizes latency of requests</li><li>Governance<ul><li>Bootstrapping </li><li>Ledger of nodes</li></ul></li><li>Nodes setup<ul><li>TLS</li><li>DNS</li></ul></li></ul><p><img loading=\"lazy\" src=\"/fleek/assets/images/fleek-network-gateway-3bb0fdcae24febe67418191541d25100.png\" width=\"2017\" height=\"1029\" class=\"img_ev3q\"></p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"security\">Security<a class=\"hash-link\" href=\"#security\" title=\"Direct link to heading\">​</a></h2><ul><li>Sybil</li><li>Eclipse</li><li>Spam</li><li>Bootstrap</li><li>Sybil/Eclipse</li></ul><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"user-story\">User story<a class=\"hash-link\" href=\"#user-story\" title=\"Direct link to heading\">​</a></h2><div class=\"language-gherkin= codeBlockContainer_Ckt0 theme-code-block\" style=\"--prism-color:#F8F8F2;--prism-background-color:#282A36\"><div class=\"codeBlockContent_biex\"><pre tabindex=\"0\" class=\"prism-code language-gherkin= codeBlock_bY9V thin-scrollbar\"><code class=\"codeBlockLines_e6Vv\"><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Feature: Accelerate Content</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  As an app</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  I want to put content onto the Ursa CDN</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  Because I want to accelerate my content worldwide</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  Given a trustless, censorship resistent premise</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  Scenario: App puts content to Ursa</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Given I'm a signed up to ursa and have an endpoint id</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    When I use the given api</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    And I make a put request with my content</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Then the content should be uploaded to the network</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    And distributed amongst peers and cached on the network and gateway</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    And the nodes will also cache the data locally until storage threshold</span><br></span></code></pre><div class=\"buttonGroup__atx\"><button type=\"button\" aria-label=\"Copy code to clipboard\" title=\"Copy\" class=\"clean-btn\"><span class=\"copyButtonIcons_eSgA\" aria-hidden=\"true\"><svg class=\"copyButtonIcon_y97N\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg><svg class=\"copyButtonSuccessIcon_LjdS\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg></span></button></div></div></div><div class=\"language-gherkin= codeBlockContainer_Ckt0 theme-code-block\" style=\"--prism-color:#F8F8F2;--prism-background-color:#282A36\"><div class=\"codeBlockContent_biex\"><pre tabindex=\"0\" class=\"prism-code language-gherkin= codeBlock_bY9V thin-scrollbar\"><code class=\"codeBlockLines_e6Vv\"><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Feature: Get Content</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  As an app</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  I want to get my content from Ursa CDN</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  Because I want to serve it to my clients</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">  Scenario: App requests for `/:cid`</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Given the App has a valid endpoint url</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    When the App makes a `Get` request for the `cid`</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Then the Gateway returns the data if it is cached</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    But if not cached, it will query the closest node</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    And if cache miss, gateways</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    And nodes will cache the content for repeated requests</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    </span><br></span></code></pre><div class=\"buttonGroup__atx\"><button type=\"button\" aria-label=\"Copy code to clipboard\" title=\"Copy\" class=\"clean-btn\"><span class=\"copyButtonIcons_eSgA\" aria-hidden=\"true\"><svg class=\"copyButtonIcon_y97N\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg><svg class=\"copyButtonSuccessIcon_LjdS\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg></span></button></div></div></div><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"user-flows\">User flows<a class=\"hash-link\" href=\"#user-flows\" title=\"Direct link to heading\">​</a></h2><div class=\"language-sequence codeBlockContainer_Ckt0 theme-code-block\" style=\"--prism-color:#F8F8F2;--prism-background-color:#282A36\"><div class=\"codeBlockContent_biex\"><pre tabindex=\"0\" class=\"prism-code language-sequence codeBlock_bY9V thin-scrollbar\"><code class=\"codeBlockLines_e6Vv\"><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Client-&gt;Gateway: Get: \"/&lt;client_endpoint&gt;/:cid\"</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Gateway-&gt;Cherry Picker: Pick closest node</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Cherry Picker-&gt;Node: Get content</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Note right of Node: From cache or content routing</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Node--&gt;Client: Returns content and caches it</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">Note left of Client: Incrementally verifies the data</span><br></span></code></pre><div class=\"buttonGroup__atx\"><button type=\"button\" aria-label=\"Copy code to clipboard\" title=\"Copy\" class=\"clean-btn\"><span class=\"copyButtonIcons_eSgA\" aria-hidden=\"true\"><svg class=\"copyButtonIcon_y97N\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg><svg class=\"copyButtonSuccessIcon_LjdS\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg></span></button></div></div></div><p><img loading=\"lazy\" src=\"/fleek/assets/images/fleek-network-user-flows-e2886fae2e678d447a48465d4b6fea74.png\" width=\"2374\" height=\"1772\" class=\"img_ev3q\"></p><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"project-timeline\">Project Timeline<a class=\"hash-link\" href=\"#project-timeline\" title=\"Direct link to heading\">​</a></h2><div class=\"language-mermaid codeBlockContainer_Ckt0 theme-code-block\" style=\"--prism-color:#F8F8F2;--prism-background-color:#282A36\"><div class=\"codeBlockContent_biex\"><pre tabindex=\"0\" class=\"prism-code language-mermaid codeBlock_bY9V thin-scrollbar\"><code class=\"codeBlockLines_e6Vv\"><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">gantt</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    title Mission no.1: First Exploration</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\" style=\"display:inline-block\"></span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    section Network</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Outline and build v0 of node spec           :a1, 2022-06-01, 30d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Develop networking stack     :after a1  , 25d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    </span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    section RPC</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Design Cache Node RPC interface      :2022-06-01  , 28d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Integrate with gateways      :20d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    </span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    section Store</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Implement an IPLD blockstore      :2022-06-01  , 20d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    </span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    section Metrics</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Determine the metrics capturing mechanism      :2022-06-01  , 30d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Determine payout for nodes serving content     : 30d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    </span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    section Daemon</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Build a local cli to interact with node      :2022-06-01  , 30d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    </span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    section Gateway</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Create a global gateway     :2022-06-01  , 24d</span><br></span><span class=\"token-line\" style=\"color:#F8F8F2\"><span class=\"token plain\">    Build a governance layer and cherry picker      : after a1  , 30d</span><br></span></code></pre><div class=\"buttonGroup__atx\"><button type=\"button\" aria-label=\"Copy code to clipboard\" title=\"Copy\" class=\"clean-btn\"><span class=\"copyButtonIcons_eSgA\" aria-hidden=\"true\"><svg class=\"copyButtonIcon_y97N\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg><svg class=\"copyButtonSuccessIcon_LjdS\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg></span></button></div></div></div><h2 class=\"anchor anchorWithStickyNavbar_LWe7\" id=\"appendix\">Appendix<a class=\"hash-link\" href=\"#appendix\" title=\"Direct link to heading\">​</a></h2><div class=\"theme-admonition theme-admonition-info alert alert--info admonition_LlT9\"><div class=\"admonitionHeading_tbUL\"><span class=\"admonitionIcon_kALy\"><svg viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg></span>info</div><div class=\"admonitionContent_S0QG\"><p><strong>More coming soon!</strong>\n<strong>This is a general overiew, paper, repo, and official announcement soon</strong></p></div></div>",
            "url": "https://docs.fleek.network/fleek/blog/the-fleek-network",
            "title": "The Fleek Network",
            "summary": "Introduction",
            "date_modified": "2023-02-16T01:41:34.000Z",
            "author": {
                "name": "Mahmoud A. Shehata",
                "url": "https://github.com/b0xtch"
            },
            "tags": [
                "fleek network",
                "blog",
                "engineering",
                "introduction"
            ]
        }
    ]
}